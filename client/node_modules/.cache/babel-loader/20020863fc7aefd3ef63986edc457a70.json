{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * lodash-like mapValues function\n * Returns new object with same keys\n * and each value equal to result of running it through provided callback\n */\n\nfunction mapValues(callback, obj) {\n  var mappedObject = {};\n\n  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n    var key = _a[_i];\n    mappedObject[key] = callback(obj[key]);\n  }\n\n  return mappedObject;\n}\n\nexports.mapValues = mapValues;\n/**\n * lodash-like mapValues function\n * Returns key of value matching search input\n */\n\nfunction findKey(value, obj) {\n  for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n    var key = _a[_i];\n\n    if (obj[key] === value) {\n      return key;\n    }\n  }\n}\n\nexports.findKey = findKey;\n/**\n * Just a throttle function\n */\n\nfunction throttle(delay, fn) {\n  var lastCall = 0;\n  var timeout = null;\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var now = new Date().getTime();\n\n    if (now - lastCall < delay) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      timeout = setTimeout(function () {\n        lastCall = now;\n        fn.apply(void 0, args);\n      }, delay);\n      return;\n    }\n\n    lastCall = now;\n    return fn.apply(void 0, args);\n  };\n}\n\nexports.throttle = throttle;\n/**\n * Helper for calculating top and bottom position of element within the screen\n * based on result of getBoundingClientRect\n */\n\nexports.getComponentBounds = function (windowHeight) {\n  return function (rect) {\n    // ELEMENT PRE TOP SCREEN EDGE\n    // when top of the element is below top of the screen and above bottom of the screen\n    if (rect.top >= 0 && rect.top <= windowHeight) {\n      return {\n        top: rect.top,\n        // bottom equals bottom of the element or bottom of the screen\n        bottom: Math.min(rect.bottom, windowHeight)\n      };\n    } // ELEMENT PAST TOP SCREEN EDGE\n    // when top of element is above top screen edge but bottom of the element is still inside\n\n\n    if (rect.top <= 0 && rect.top + rect.height >= 0) {\n      return {\n        top: 0,\n        bottom: Math.min(rect.top + rect.height, windowHeight)\n      };\n    } // outside of the screen\n\n\n    return {\n      top: -1,\n      bottom: -1\n    };\n  };\n};","map":{"version":3,"sources":["/Users/bahar/Desktop/bhosseini/client/node_modules/react-single-page-navigation/dist/src/utils.js"],"names":["Object","defineProperty","exports","value","mapValues","callback","obj","mappedObject","_i","_a","keys","length","key","findKey","throttle","delay","fn","lastCall","timeout","args","arguments","now","Date","getTime","clearTimeout","setTimeout","apply","getComponentBounds","windowHeight","rect","top","bottom","Math","min","height"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * lodash-like mapValues function\n * Returns new object with same keys\n * and each value equal to result of running it through provided callback\n */\nfunction mapValues(callback, obj) {\n    var mappedObject = {};\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var key = _a[_i];\n        mappedObject[key] = callback(obj[key]);\n    }\n    return mappedObject;\n}\nexports.mapValues = mapValues;\n/**\n * lodash-like mapValues function\n * Returns key of value matching search input\n */\nfunction findKey(value, obj) {\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n}\nexports.findKey = findKey;\n/**\n * Just a throttle function\n */\nfunction throttle(delay, fn) {\n    var lastCall = 0;\n    var timeout = null;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var now = new Date().getTime();\n        if (now - lastCall < delay) {\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(function () {\n                lastCall = now;\n                fn.apply(void 0, args);\n            }, delay);\n            return;\n        }\n        lastCall = now;\n        return fn.apply(void 0, args);\n    };\n}\nexports.throttle = throttle;\n/**\n * Helper for calculating top and bottom position of element within the screen\n * based on result of getBoundingClientRect\n */\nexports.getComponentBounds = function (windowHeight) { return function (rect) {\n    // ELEMENT PRE TOP SCREEN EDGE\n    // when top of the element is below top of the screen and above bottom of the screen\n    if (rect.top >= 0 && rect.top <= windowHeight) {\n        return {\n            top: rect.top,\n            // bottom equals bottom of the element or bottom of the screen\n            bottom: Math.min(rect.bottom, windowHeight)\n        };\n    }\n    // ELEMENT PAST TOP SCREEN EDGE\n    // when top of element is above top screen edge but bottom of the element is still inside\n    if (rect.top <= 0 && rect.top + rect.height >= 0) {\n        return {\n            top: 0,\n            bottom: Math.min(rect.top + rect.height, windowHeight)\n        };\n    }\n    // outside of the screen\n    return { top: -1, bottom: -1 };\n}; };\n"]},"metadata":{},"sourceType":"script"}